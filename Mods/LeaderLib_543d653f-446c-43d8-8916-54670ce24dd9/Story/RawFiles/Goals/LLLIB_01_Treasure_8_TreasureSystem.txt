Version 1
SubGoalCombiner SGC_AND
INITSECTION
//REGION REGISTERED
//DB_LLLIB_Treasure_RegisteredObject(_TreasureID, _Object)
//DB_LLLIB_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
//DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
//DB_LLLIB_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)

//DB_LLLIB_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
//DB_LLLIB_Treasure_TreasureItemStats(_TreasureID, _ItemEntry, _Amount, _RequirementID)
//DB_LLLIB_Treasure_ItemLevel(_TreasureID, _ItemEntry, _MinLevel, _MaxLevel, _UsePartyLevel)
//DB_LLLIB_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _GenerationType)
//DB_LLLIB_Treasure_RegisteredGenerationTypes(_GenerationType)
//DB_LLLIB_Treasure_ItemGenerationFlag(_TreasureID, _ItemEntry, _Flag, _FlagType)
//DB_LLLIB_Treasure_ItemDeltaMods(_TreasureID, _ItemEntry, _Deltamod, _Chance)
//DB_LLLIB_Treasure_ItemRunes(_TreasureID, _ItemEntry, _Rune, _Chance)
//DB_LLLIB_Treasure_ItemMaxAmount(_TreasureID, _ItemEntry, _MaxAmount)

//DB_LLLIB_Treasure_OnlyOnce(_TreasureID, _ItemEntryOrTreasureTable, _OnCompletionEvent)
//DB_LLLIB_Treasure_GeneratedEvent(_TreasureID, _ItemEntry, _OnGeneratedEvent)
//DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
//END_REGION
//DB_LLLIB_Treasure_StatToTemplate(_ItemEntry, _ItemTemplate)
//DB_LLLIB_Treasure_GeneratorDummies(_Dummy)

//DB_LLLIB_Treasure_Temp_DummyTarget(_Object, _Dummy, _TreasureID, _ItemEntry, _DummyID, _QueueEntryID)
//DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
//DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
//DB_LLLIB_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID)
//DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID)
//DB_LLLIB_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate)
//DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _CreatedAmount, _MaxAmount, _IsStat)
//DB_LLLIB_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID)
//DB_LLLIB_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID)
/*GENERATION_QUEUE*/
//DB_LLLIB_Array_Data("LLLIB_ItemGenerationQueue", _Index, _ID)
//DB_LLLIB_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
//DB_LLLIB_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID)
//DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
//DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat)
KBSECTION
//REGION UPDATER
PROC
LLLIB_System_RegisterDatabases()
THEN
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_StatToTemplate", 2);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_DummyTarget", 6);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_MatchedTreasure", 2);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure", 2);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_FlagToTreasure", 3);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure", 2);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_AmountToCreate", 3);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_GenerateItem", 7);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_Queue_CountTemplate", 5);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_Queue_CountStat", 6);
LeaderUpdater_Register_Database("LeaderLib", "LaughingLeader", "TreasureSystem", "DB_LLLIB_Treasure_Temp_ItemGenerationQueue", 4);
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem] Databases registered.");
//END_REGION

//REGION GETTERS
QRY
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
DB_LLLIB_Treasure_RegisteredObject(_TreasureID, _Object)
THEN
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
GetTemplate(_Object, _Template)
AND
DB_LLLIB_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
THEN
DB_LLLIB_Treasure_Temp_MatchedTreasure((GUIDSTRING)_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
DB_LeaderLib_Traders_Active((CHARACTERGUID)_Object, _TraderID, _Level)
AND
DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
THEN
DB_LLLIB_Treasure_Temp_MatchedTreasure((GUIDSTRING)_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID, (STRING)_GenerationType)
THEN
LLLIB_Treasure_Internal_GetTreasureObject_ClearPreviousTemp(_TreasureID, _GenerationType);

PROC
LLLIB_Treasure_Internal_GetTreasureObject_ClearPreviousTemp((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType)
THEN
NOT DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType);

PROC
LLLIB_Treasure_Internal_GetTreasureObject_ClearPreviousTemp((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_RegisteredObject(_TreasureID, _Object)
THEN
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
THEN
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Trader, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
AND
NOT DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType)
THEN
DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem] Launching iterators to find object with template [",_Template,"] for [",_TreasureID,":",_GenerationType,"]");
CharacterLaunchIterator("LLLIB_Events_Treasure_FindObject");
ItemLaunchIterator("LLLIB_Events_Treasure_FindObject");

IF
StoryEvent(_Object, "LLLIB_Events_Treasure_FindObject")
AND
GetTemplate(_Object, _Template)
AND
DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType)
THEN
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
LeaderLib_SendEvent("LLLIB_Events_Treasure_ContinueGeneration");

/*
IF
StoryEvent(NULL_00000000-0000-0000-0000-000000000000, "LLLIB_Events_Treasure_FindObject")
AND
DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template)
THEN
NOT DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template);
*/

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID)
AND
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_, _TreasureID)
AND
DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
AND
DB_LeaderLib_Traders_Active(_Object, _TraderID, _Level)
THEN
DB_LLLIB_Treasure_Temp_MatchedTreasure((GUIDSTRING)_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByGenerationType((STRING)_GenerationType)
AND
DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID)
THEN
NOT DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByGenerationType((STRING)_GenerationType)
AND
DB_LLLIB_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
AND
NOT DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID)
THEN
DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByGenerationType((STRING)_GenerationType)
AND
DB_LLLIB_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _GenerationType)
AND
NOT DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID)
THEN
DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByRequirement((STRING)_RequirementID)
AND
DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
NOT DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByRequirement((STRING)_RequirementID)
AND
DB_LLLIB_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
AND
NOT DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByRequirement((STRING)_RequirementID)
AND
DB_LLLIB_Treasure_TreasureItemStats(_TreasureID, _ItemEntry, _Amount, _RequirementID)
AND
NOT DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByRequirement((STRING)_RequirementID)
AND
DB_LLLIB_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
NOT DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);
//END_REGION

//REGION QUERIES_CHECKS
QRY
LeaderLib_Treasure_QRY_IsRegisteredObject((GUIDSTRING)_Object)
AND
DB_LLLIB_Treasure_RegisteredObject(_TreasureID, _Object)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_IsRegisteredObject((CHARACTERGUID)_Object)
AND
DB_LeaderLib_Traders_Active(_Object, _TraderID, _Level)
AND
DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_IsRegisteredObject((GUIDSTRING)_Object)
AND
NOT DB_LLLIB_Treasure_RegisteredObject(_, _Object)
AND
GetTemplate(_Object, _Template)
AND
DB_LLLIB_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("DEFAULT")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("MANUAL")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("OPENED")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("TRADE_GENERATION_END")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerateWithType((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerateWithType((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_GenerationType)
AND
NOT DB_LLLIB_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _)
AND
DB_LLLIB_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerateWithType((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_GenerationType)
AND
NOT DB_LLLIB_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _)
AND
NOT DB_LLLIB_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
AND
LeaderLib_Treasure_QRY_GenerationTypeIsDefault(_GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerate((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_RequirementID, "MANUAL")
AND
LeaderLib_Requirements_QRY_AllMet(_RequirementID)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerate((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_RequirementID, (STRING)_GenerationType)
AND
LeaderLib_Treasure_QRY_ItemCanGenerateWithType(_TreasureID, _ItemEntry, _GenerationType)
AND
LeaderLib_Requirements_QRY_AllMet(_RequirementID)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ObjectCanStartGeneration((GUIDSTRING)_Object)
AND
NOT ObjectGetFlag(_Object, "LLLIB_Treasure_GenerationEnded", 1)
AND
NOT ObjectGetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure", 1)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureHasGenerationType((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureHasGenerationType((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_ItemGenerationType(_TreasureID, _, _GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureMatch((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LLLIB_Treasure_RegisteredObject(_TreasureID, _Object)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureMatch((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
GetTemplate(_Object, _Template)
AND
DB_LLLIB_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureMatch((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LeaderLib_Traders_Active((CHARACTERGUID)_Object, _TraderID, _Level)
AND
DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
THEN
DB_NOOP(1);
//END_REGION

//REGION TREASURE_TABLE_QUERIES
//Default to 1
QRY
LeaderLib_Treasure_QRY_TreaureTableLimitReached((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT DB_LLLIB_Treasure_TreasureTableLimit(_TreasureID, _TreasureTable, _)
AND
DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _Count)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreaureTableLimitReached((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
DB_LLLIB_Treasure_TreasureTableLimit(_TreasureID, _TreasureTable, _Limit)
AND
DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _Count)
AND
_Count >= _Limit
THEN
DB_NOOP(1);
//END_REGION

//REGION TREASURE_TABLE_GENERATION
PROC
LLLIB_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
NOT LeaderLib_Treasure_QRY_TreaureTableLimitReached(_Object, _TreasureID, _TreasureTable)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _TreasureTable, _RequirementID, _GenerationType)
AND
_UsePartyLevel > 0
AND
LeaderLib_Helper_QRY_GetHighestPlayerLevel()
AND
DB_LeaderLib_Helper_Temp_HighestPlayerLevel(_Level)
THEN
LLLIB_Treasure_Internal_GenerateTreasureTable(_ID, _Object, _TreasureID, _GenerationType, _Level, _TreasureTable);

PROC
LLLIB_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
NOT LeaderLib_Treasure_QRY_TreaureTableLimitReached(_Object, _TreasureID, _TreasureTable)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _TreasureTable, _RequirementID, _GenerationType)
AND
_UsePartyLevel <= 0
AND
LeaderLib_Random_QRY(_MinLevel, _MaxLevel)
AND
DB_LeaderLib_Temp_RandomResult(_Level)
THEN
NOT DB_LeaderLib_Temp_RandomResult(_Level);
LLLIB_Treasure_Internal_GenerateTreasureTable(_ID, _Object, _TreasureID, _GenerationType, _Level, _TreasureTable);

PROC
LLLIB_Treasure_Internal_GenerateTreasureTable((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType, (INTEGER)_Level, (STRING)_TreasureTable)
AND
GetPosition(_Object, _x, _y, _z)
AND
CreateItemTemplateAtPosition("LOOT_BackPack_A_6c70c298-aa29-418f-a659-f8e0b5f5fa60", _x, _y, _z, _Backpack)
THEN
SetTag(_Backpack, "LeaderLib_Internal_TreasureTableContainer");
SetVarString(_Backpack, "LeaderLib_Internal_TreasureID", _TreasureID);
SetVarString(_Backpack, "LeaderLib_Internal_TreasureTable", _TreasureTable);
SetVarObject(_Backpack, "LeaderLib_Internal_TreasureTarget", _Object);
SetVarString(_Backpack, "LeaderLib_Internal_ItemGenID", _ID);
GenerateTreasure(_Backpack, _TreasureTable, _Level, NULL_00000000-0000-0000-0000-000000000000);
//LeaderLib_StartObjectTimer(_Backpack, 100, "LeaderLib_Timers_Internal_MoveTreasureTableItems_", "LeaderLib_Events_Internal_MoveTreasureTableItems");
SetStoryEvent(_Backpack, "LeaderLib_Events_Internal_MoveTreasureTableItems"); // So the ItemAdded events can fire first

IF
ItemAddedToContainer(_Item, _Container)
AND
IsTagged(_Container, "LeaderLib_Internal_TreasureTableContainer", 1)
AND
GetVarString(_Container, "LeaderLib_Internal_TreasureID", _TreasureID)
AND
GetVarString(_Container, "LeaderLib_Internal_TreasureTable", _TreasureTable)
AND
GetVarObject(_Container, "LeaderLib_Internal_TreasureTarget", _Object)
THEN
LeaderLib_Treasure_Internal_CheckPostGenBonusesForTable(_Object, _Item, _TreasureID, _TreasureTable);

PROC
LeaderLib_Treasure_Internal_CheckPostGenBonusesForTable((GUIDSTRING)_Object, (ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT LeaderLib_Treasure_QRY_TreasureTableUsesTemplates(_TreasureID, _TreasureTable)
AND
GetStatString(_Item, _ItemEntry)
AND
LeaderLib_Treasure_QRY_HasPostGenerationBonuses(_TreasureID, _ItemEntry)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:ItemAddedToContainer(TreasureTableContainer:Stat)] Item [",_ItemEntry,"] generated from treasure [",_TreasureID,"] with table [",_TreasureTable,"] has post-gen bonuses.");
DB_LLLIB_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry);

PROC
LeaderLib_Treasure_Internal_CheckPostGenBonusesForTable((GUIDSTRING)_Object, (ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
LeaderLib_Treasure_QRY_TreasureTableUsesTemplates(_TreasureID, _TreasureTable)
AND
GetTemplate(_Item, _ItemEntry)
AND
LeaderLib_Treasure_QRY_HasPostGenerationBonuses(_TreasureID, _ItemEntry)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:ItemAddedToContainer(TreasureTableContainer:Template)] Item [",_ItemEntry,"] generated from treasure [",_TreasureID,"] with table [",_TreasureTable,"] has post-gen bonuses.");
DB_LLLIB_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry);

IF
StoryEvent((ITEMGUID)_Container, "LeaderLib_Events_Internal_MoveTreasureTableItems")
AND
GetVarString(_Container, "LeaderLib_Internal_TreasureID", _TreasureID)
AND
GetVarString(_Container, "LeaderLib_Internal_TreasureTable", _TreasureTable)
AND
GetVarObject(_Container, "LeaderLib_Internal_TreasureTarget", _Object)
AND
GetVarString(_Container, "LeaderLib_Internal_ItemGenID", _ID)
THEN
MoveAllItemsTo(_Container, _Object, 0, 0, 1);
ItemRemove(_Container);
LLLIB_Treasure_Internal_IncreaseTreasureTableCount(_Object, _TreasureID, _TreasureTable);
LLLIB_Treasure_Internal_OnTreasureTableGenerated(_ID, _Object, _TreasureID, _TreasureTable);

PROC
LLLIB_Treasure_Internal_OnTreasureTableGenerated((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _, _, _, _, _)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnTreasureTableGenerated] Generated treasure table [",_TreasureTable,"] for treasure [",_TreasureID,"].");
LLLIB_Treasure_Internal_MarkAsFinished(_ID, _Object, _TreasureID);

PROC
LLLIB_Treasure_Internal_IncreaseTreasureTableCount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _Count)
AND
IntegerSum(_Count, 1, _NextCount)
THEN
NOT DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _Count);
DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _NextCount);

PROC
LLLIB_Treasure_Internal_IncreaseTreasureTableCount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _)
THEN
DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, 1);

/*Older saves*/
IF
StoryEvent(_, "LeaderLib_Initialized")
AND
DB_LLLIB_Treasure_TableWasGenerated((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _)
THEN
DB_LLLIB_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, 1);

QRY
LeaderLib_Treasure_QRY_TreasureTableUsesTemplates((STRING)_TreasureID, (STRING)_TreasureTable)
AND
DB_LLLIB_Treasure_TreasureTableItemEntryMode(_TreasureID, _TreasureTable, 1)
THEN
DB_NOOP(1);
//END_REGION

//REGION INDIVIDUAL_TREASURE_GENERATION_QUEUE

PROC
LLLIB_Treasure_Internal_CreateTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
Random(999999, _Ran)
AND
IntegertoString(_Ran, _RanStr)
AND
LeaderLog_QRY_Log("COMBINE", _ID, "_TreasureQueue_", "_", _RanStr)
AND
DB_LeaderLog_Temp_CombinedString(_TreasureQueueID)
THEN
NOT DB_LeaderLog_Temp_CombinedString(_TreasureQueueID);
DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID);

PROC
LLLIB_Treasure_Internal_AddItemEntryToTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (STRING)_GenerationType, (INTEGER)_IsStat)
AND
NOT DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
AND
DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
THEN
LeaderLib_Array_AddToArray(_TreasureQueueID, _ItemEntry);
DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);

PROC
LLLIB_Treasure_Internal_StartTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
AND
NOT LeaderLib_Array_QRY_EmptyLength(_TreasureQueueID)
AND
NOT DB_LLLIB_Treasure_GenerationSpeed(_TreasureID, _)
AND
DB_LLLIB_Settings_QueueRates("ItemGeneration", _TickRate, _TimeoutRate)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:StartTreasureQueue] Starting treasure queue with a set _TickRate and _TimeoutRate for treasure [",_TreasureID,"].");
LLLIB_Treasure_Internal_StartTreasureQueueWithRates(_ID, _TreasureQueueID, _TickRate, _TimeoutRate);

PROC
LLLIB_Treasure_Internal_StartTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
AND
NOT LeaderLib_Array_QRY_EmptyLength(_TreasureQueueID)
AND
DB_LLLIB_Treasure_GenerationSpeed(_TreasureID, _TickRate)
AND
DB_LLLIB_Settings_QueueRates("ItemGeneration", _, _TimeoutRate)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:StartTreasureQueue] Starting treasure queue with a set _TimeoutRate for treasure [",_TreasureID,"].");
LLLIB_Treasure_Internal_StartTreasureQueueWithRates(_ID, _TreasureQueueID, _TickRate, _TimeoutRate);

PROC
LLLIB_Treasure_Internal_StartTreasureQueueWithRates((STRING)_ID, (STRING)_TreasureQueueID, (INTEGER)_TickRate, (INTEGER)_TimeoutRate)
//AND
//_TickRate > 0
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:StartTreasureQueueWithRates] Starting treasure queue [",_TreasureQueueID,"].");
LeaderLib_Queue_Create(_TreasureQueueID, _TreasureQueueID, "LLLIB_Timers_Treasure_TreasureQueue", _TickRate, "LLLIB_Events_Treasure_ProcessTreasureItem", "LLLIB_Events_OnItemGenerationComplete", "LLLIB_Events_OnTreasureQueueComplete");
LeaderLib_Queue_SetTimeout(_TreasureQueueID, "LLLIB_Timers_Treasure_ItemQueueTimeout", _TimeoutRate, "LLLIB_Events_OnItemGenerationTimeout");
LeaderLib_Queue_Start(_TreasureQueueID);

/*
PROC
LLLIB_Treasure_Internal_StartTreasureQueueWithRates((STRING)_ID, (STRING)_TreasureQueueID, (INTEGER)_TickRate, (INTEGER)_TimeoutRate)
AND
_TickRate <= 0
AND
DB_LLLIB_Array_Data(_TreasureQueueID, _Index, _ItemEntry)
AND
DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat)
THEN
DB_LLLIB_Queue_Temp_CurrentEntry(_ID, _ItemEntry);
LLLIB_Treasure_Internal_ProcessItemEntry(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);

PROC
LLLIB_Treasure_Internal_ClearQueueEntry((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);
THEN
NOT DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);

PROC
LLLIB_Treasure_Internal_StartTreasureQueueWithRates((STRING)_ID, (STRING)_TreasureQueueID, (INTEGER)_TickRate, (INTEGER)_TimeoutRate)
AND
_TickRate <= 0
AND
NOT DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _, _, _, _, _, _, _)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:StartTreasureQueueWithRates] Treasure queue [",_TreasureQueueID,"] _TickRate was less than 0. Completed queue instantly.");
LeaderLib_Array_ClearArray(_TreasureQueueID);
NOT DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID);
LeaderLib_SendEvent("LLLIB_Events_OnTreasureQueueComplete");
*/

PROC
LLLIB_Treasure_Internal_StartTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
AND
LeaderLib_Array_QRY_EmptyLength(_TreasureQueueID)
THEN
NOT DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID);
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:StartTreasureQueue] Treasure queue [",_TreasureID,"] is empty. Skipping.");
LeaderLib_SendEvent("LLLIB_Events_OnTreasureQueueComplete");

IF
StoryEvent(_, "LLLIB_Events_Treasure_ProcessTreasureItem")
AND
DB_LLLIB_Queue_Temp_CurrentEntry(_QueueID, _ItemEntry)
AND
DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat)
THEN
NOT DB_LLLIB_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);
LLLIB_Treasure_Internal_ProcessItemEntry(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);

IF
StoryEvent(_, "LLLIB_Events_OnTreasureQueueComplete")
AND
DB_LLLIB_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID)
AND
DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
THEN
LeaderLib_Queue_Stop(_TreasureQueueID);
LeaderLib_Queue_ClearQueue(_TreasureQueueID);
NOT DB_LLLIB_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID);

IF
StoryEvent(_, "LLLIB_Events_OnTreasureQueueComplete")
AND
DB_LLLIB_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:OnTreasureQueueComplete] Treasure queue [",_TreasureID,"] complete.");
LLLIB_Treasure_Internal_MarkAsFinished(_ID, _Object, _TreasureID);
//END_REGION

//REGION TREASURE_FINISHED_FAILED
PROC
LLLIB_Treasure_Internal_MarkAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LLLIB_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID)
THEN
NOT DB_LLLIB_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID);

PROC
LLLIB_Treasure_Internal_MarkAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT LeaderLib_Treasure_QRY_StillInQueue(_Object)
AND
NOT LeaderLib_Treasure_QRY_StillGenerating(_ID, _Object, _TreasureID)
THEN
LeaderLib_Treasure_ResetDummyByID(_ID);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:MarkAsFinished] Generation finished for [",_ID,"]. Setting 'LLLIB_Treasure_GenerationSuccessful' flag to true.");
ObjectSetFlag(_Object, "LLLIB_Treasure_GenerationSuccessful");

PROC
LLLIB_Treasure_Internal_MarkAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT LeaderLib_Treasure_QRY_StillGenerating(_ID, _Object, _TreasureID)
AND
ObjectIsCharacter(_Object, 1)
THEN
LLLIB_Treasure_Internal_RemoveFromJustRegistered((CHARACTERGUID)_Object, _TreasureID);

PROC
LLLIB_Treasure_Internal_MarkAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT LeaderLib_Treasure_QRY_StillGenerating(_ID, _Object, _TreasureID)
THEN
LLLIB_Treasure_Internal_OnGenerationFinished(_ID, _Object, _TreasureID);

PROC
LLLIB_Treasure_Internal_MarkItemAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
THEN
LLLIB_Treasure_SendGeneratedEvent(_Object, _TreasureID, _ItemEntry);
LLLIB_Treasure_RemoveIfOnlyOnce(_Object, _TreasureID, _ItemEntry);
LeaderLib_SendEvent("LLLIB_Events_OnItemGenerationComplete");

PROC
LLLIB_Treasure_Internal_OnItemGenerationFailed((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
THEN
LeaderLib_SendEvent("LLLIB_Events_OnItemGenerationTimeout");
//END_REGION

//REGION GENERATE_ITEMS
PROC
LLLIB_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
THEN
LLLIB_Treasure_Internal_AddItemEntryToTreasureQueue(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, 0);

PROC
LLLIB_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LLLIB_Treasure_TreasureItemStats(_TreasureID, _ItemEntry, _Amount, _RequirementID)
THEN
LLLIB_Treasure_Internal_AddItemEntryToTreasureQueue(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, 1);

PROC
LLLIB_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT DB_LLLIB_Treasure_TreasureItemTemplates(_TreasureID, _, _, _)
AND
NOT DB_LLLIB_Treasure_TreasureItemStats(_TreasureID, _, _, _)
AND
NOT DB_LLLIB_Treasure_RegisteredTreasureTable(_TreasureID, _, _, _, _, _)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:GenerateItems] Skipping generation for items with [",_ID,"]: No entries found for Treasure ID [",_TreasureID,"].");
LLLIB_Treasure_Internal_OnGenerationFinished(_ID, _Object, _TreasureID);
//LLLIB_Treasure_Internal_OnGenerationFailed(_ID, _Object, _TreasureID, _GenerationType);

PROC
LLLIB_Treasure_Internal_ProcessItemEntry((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (STRING)_GenerationType, (INTEGER)_IsStat)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:ProcessItemEntry] Processing item entry [",_ItemEntry,"] for treasure [",_TreasureID,"].");

PROC
LLLIB_Treasure_Internal_ProcessItemEntry((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (STRING)_GenerationType, (INTEGER)_IsStat)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _ItemEntry, _RequirementID, _GenerationType)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:ProcessItemEntry] Starting generation for [",_ID,"][",_ItemEntry,"].");
LLLIB_Treasure_Internal_StartItemGeneration(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _IsStat);

PROC
LLLIB_Treasure_Internal_ProcessItemEntry((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (STRING)_GenerationType, (INTEGER)_IsStat)
AND
NOT LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _ItemEntry, _RequirementID, _GenerationType)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:ProcessItemEntry] Skipping generation for [",_ID,"]. Treasure [",_TreasureID,"] does not pass the requirements.");
LeaderLib_SendEvent("LLLIB_Events_OnItemGenerationComplete");

PROC
LLLIB_Treasure_Internal_StartItemGeneration((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (INTEGER)_IsStat)
AND
LeaderLib_Treasure_QRY_SkipAmountCheck(_Object, _TreasureID, _ItemEntry)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:GenerateItems] Skipping amount check and generating item [",_TreasureID,"]:[",_ItemEntry,"].");
ObjectSetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure");
DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, 0, _Amount, _IsStat);

PROC
LLLIB_Treasure_Internal_StartItemGeneration((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, 0)
AND
NOT LeaderLib_Treasure_QRY_SkipAmountCheck(_Object, _TreasureID, _ItemEntry)
AND
LeaderLib_Treasure_QRY_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry)
THEN
DB_LLLIB_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID);
LLLIB_Treasure_Internal_CountingComplete(_ID, _Object, _TreasureID, _ItemEntry, 0);

PROC
LLLIB_Treasure_Internal_StartItemGeneration((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, 1)
AND
NOT LeaderLib_Treasure_QRY_SkipAmountCheck(_Object, _TreasureID, _ItemEntry)
AND
NOT DB_LLLIB_Treasure_StatToTemplate(_ItemEntry, _)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:Treasure:StartItemGeneration] Object is missing stat-based [",_TreasureID,"]:[",_ItemEntry,"] item template. Skipping counting.");
ObjectSetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure");
DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, 0, _Amount, 1);

PROC
LLLIB_Treasure_Internal_StartItemGeneration((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, 1)
AND
NOT DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _, _, 1)
AND
NOT LeaderLib_Treasure_QRY_SkipAmountCheck(_Object, _TreasureID, _ItemEntry)
AND
DB_LLLIB_Treasure_StatToTemplate(_ItemEntry, _ItemTemplate)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:Treasure:StartItemGeneration] Starting stat-based object counting for [",_TreasureID,"]:[",_ItemEntry,"] with template [",_ItemTemplate,"].");
SetVarString(_Object, "LeaderLib_Internal_TreasureQueueID", _ID);
SetVarString(_Object, "LeaderLib_Internal_TreasureID", _TreasureID);
LeaderLib_Treasure_CountTemplateWithStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry);
DB_LLLIB_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _Amount, _RequirementID);

IF
StoryEvent(_Object, "LeaderLib_Events_Treasure_Internal_StatCountingComplete")
AND
GetVarString(_Object, "LeaderLib_Internal_TreasureQueueID", _ID)
AND
DB_LLLIB_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _Amount, _RequirementID)
AND
LeaderLib_Treasure_QRY_CountedItems(_Object, _TreasureID, _ItemEntry)
AND
IntegertoString(_Amount, _AmountStr)
THEN
SetVarString(_Object, "LeaderLib_Internal_TreasureQueueID", "");
SetVarString(_Object, "LeaderLib_Internal_TreasureID", "");
LeaderLog_Log("TRACE", "[LeaderLib:Treasure:StartItemGeneration] Object counting complete. Treasure [",_TreasureID,"] | Stat [",_ItemEntry,"] | Amount [",_AmountStr,"]");
LLLIB_Treasure_Internal_CountingComplete(_ID, _Object, _TreasureID, _ItemEntry, 1);

IF
DB_LLLIB_Treasure_Temp_GenerateItem((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_CreatedAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
THEN
NOT DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _CreatedAmount, _MaxAmount, _IsStat);
LLLIB_Treasure_Internal_GenerateItemNow(_ID, _Object, _TreasureID, _ItemEntry, _CreatedAmount, _MaxAmount, _IsStat);

PROC
LLLIB_Treasure_Internal_GenerateItemNow((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_CreatedAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_IsStat <= 0
AND
_CreatedAmount < _MaxAmount
AND
IntegerSum(_CreatedAmount, 1, _NextAmount)
AND
IntegertoString(_NextAmount, _AmountStr)
AND
IntegertoString(_MaxAmount, _MaxAmountStr)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:GenerateItems] Generating item [",_TreasureID,"]:[",_ItemEntry,"] [",_AmountStr,"/",_MaxAmountStr,"].");

PROC
LLLIB_Treasure_Internal_GenerateItemNow((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_CreatedAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_IsStat <= 0
AND
_CreatedAmount < _MaxAmount
AND
IntegerSum(_CreatedAmount, 1, _NextAmount)
AND
GetPosition(_Object, _x,_y,_z)
AND
CreateItemTemplateAtPosition(_ItemEntry, _x,_y,_z, _Item)
THEN
LeaderLib_Treasure_Internal_CheckPostGenBonuses(_Object, _Item, _TreasureID, _ItemEntry);
ItemToInventory(_Item, _Object, 1, 0, 1);
LLLIB_Treasure_Internal_IncrementGeneratedItem(_ID, _Object, _TreasureID, _ItemEntry, _NextAmount, _MaxAmount, _IsStat);

PROC
LLLIB_Treasure_Internal_IncrementGeneratedItem((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_NextAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_NextAmount < _MaxAmount
THEN
DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _NextAmount, _MaxAmount, _IsStat);

PROC
LLLIB_Treasure_Internal_IncrementGeneratedItem((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_NextAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_NextAmount >= _MaxAmount
THEN
LLLIB_Treasure_Internal_FinishIfMaxAmount(_Object, _TreasureID, _ItemEntry, _NextAmount);
LLLIB_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _ItemEntry);

PROC
LLLIB_Treasure_Internal_IncrementGeneratedItem((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_NextAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_NextAmount >= _MaxAmount
AND
DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _Max, _IsStat)
THEN
NOT DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _Max, _IsStat);

PROC
LLLIB_Treasure_Internal_GenerateItemNow((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_CreatedAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_IsStat > 0
AND
_CreatedAmount < _MaxAmount
AND
StringConcatenate("CreateByStat_", _ID, _ArrayPrefix)
AND
StringConcatenate("LeaderLib_Events_Treasure_OnStatItemsGenerated_", _ID, _CompletionEvent)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:GenerateItems] Generating stat item [",_TreasureID,"]:[",_ItemEntry,"] via [LeaderLib_Treasure_CreateItemByStat].");
LeaderLib_CreateByStat_CreateQueue(_Object, _ArrayPrefix, 5, 2500, _CompletionEvent);
DB_LLLIB_Treasure_Temp_CreatingByStat(_ID, _Object, _TreasureID, _ItemEntry, _MaxAmount, _ArrayPrefix, _CompletionEvent);
LeaderLib_CreateByStat_AddToQueue(_Object, _ArrayPrefix, _ItemEntry, _MaxAmount, 1, 0);
LeaderLib_CreateByStat_Start(_Object, _ArrayPrefix);

IF
StoryEvent(_Object, _CompletionEvent)
AND
DB_LLLIB_Treasure_Temp_CreatingByStat(_ID, _Object, _TreasureID, _ItemEntry, _MaxAmount, _ArrayPrefix, _CompletionEvent)
THEN
NOT DB_LLLIB_Treasure_Temp_CreatingByStat(_ID, _Object, _TreasureID, _ItemEntry, _MaxAmount, _ArrayPrefix, _CompletionEvent);
LLLIB_Treasure_Internal_FinishIfMaxAmount(_Object, _TreasureID, _ItemEntry, _MaxAmount);
LLLIB_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _ItemEntry);

PROC
LLLIB_Treasure_Internal_FinishIfMaxAmount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount)
AND
NOT DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
AND
DB_LLLIB_Treasure_ItemMaxAmount(_TreasureID, _ItemEntry, _MaxAmount)
AND
_Amount >= _MaxAmount
AND
NOT LeaderLib_Treasure_QRY_CanKeepGenerating(_TreasureID, _ItemEntry)
AND
GetTemplate(_Object, _Template)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:Treasure:LLLIB_Treasure_Internal_FinishIfMaxAmount] [",_TreasureID,"]:[",_ItemEntry,"] reached the max item limit set, and is done generating on object [",_Template,"].");
DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry);

PROC
LLLIB_Treasure_Internal_FinishIfMaxAmount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount)
AND
NOT DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
AND
NOT DB_LLLIB_Treasure_ItemMaxAmount(_TreasureID, _ItemEntry, _)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 0)
AND
NOT LeaderLib_Treasure_QRY_CanKeepGenerating(_TreasureID, _ItemEntry)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:Treasure:LLLIB_Treasure_Internal_FinishIfMaxAmount] [",_TreasureID,"]:[",_ItemEntry,"] has no max limit set, and the tag [LeaderLib_Treasure_GenerateEndlessly] is not set. Finialized generating ItemEntry on object.");
DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry);

QRY
LeaderLib_Treasure_QRY_CanKeepGenerating((STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_KeepGeneratingTreasure(_TreasureID)
AND
NOT DB_LLLIB_Treasure_KeepGeneratingItem(_TreasureID, _ItemEntry, 0)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_CanKeepGenerating((STRING)_TreasureID, (STRING)_ItemEntry)
AND
NOT DB_LLLIB_Treasure_KeepGeneratingTreasure(_TreasureID)
AND
DB_LLLIB_Treasure_KeepGeneratingItem(_TreasureID, _ItemEntry, 1)
THEN
DB_NOOP(1);
//END_REGION

//REGION GENERATION_QUEUE_QUERIES
QRY
LeaderLib_Treasure_QRY_StillInQueue((GUIDSTRING)_Object)
AND
DB_LLLIB_Treasure_Temp_ItemGenerationQueue(_, _Object, _, _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_StillGenerating((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _CreatedAmount, _MaxAmount, _IsStat)
THEN
DB_NOOP(1);
//END_REGION

//REGION GENERATION_QUEUE
PROC
LeaderLib_Treasure_AddToGenerationQueue((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT DB_LLLIB_Treasure_Temp_ItemGenerationQueue(_, _Object, _TreasureID, _)
AND
Random(999999, _Ran)
AND
IntegertoString(_Ran, _RanStr)
AND
GetUUID(_Object, _ObjectID)
AND
LeaderLog_QRY_Log("COMBINE", _ObjectID, "_", _TreasureID, "_", _GenerationType, "_", _RanStr)
AND
DB_LeaderLog_Temp_CombinedString(_ID)
THEN
NOT DB_LeaderLog_Temp_CombinedString(_ID);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:AddToGenerationQueue] Added [",_ID,"] to generation queue.");
LeaderLib_Array_AddToArray("LLLIB_ItemGenerationQueue", _ID);
DB_LLLIB_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType);

PROC
LeaderLib_Treasure_StartQueue()
AND
LeaderLib_Array_QRY_EmptyLength("LLLIB_ItemGenerationQueue")
THEN
LeaderLib_SendEvent("LLLIB_Events_OnGenerationQueueComplete");

PROC
LeaderLib_Treasure_StartQueue()
AND
DB_LLLIB_Array_Length("LLLIB_ItemGenerationQueue", _Length)
AND
_Length == 1
AND
DB_LLLIB_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
AND
DB_LLLIB_Array_Data("LLLIB_ItemGenerationQueue", _Index, _ID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartQueue] Single entry detected. Skipping queue and generating [",_ID,"] directly.");
LLLIB_Treasure_Internal_ProcessQueueItem(_ID);
LeaderLib_Array_RemoveFromArray("LLLIB_ItemGenerationQueue", _Index, _ID);
LeaderLib_SendEvent("LLLIB_Events_OnGenerationQueueComplete");

PROC
LeaderLib_Treasure_StartQueue()
AND
DB_LLLIB_Array_Length("LLLIB_ItemGenerationQueue", _Length)
AND
_Length > 1
AND
DB_LLLIB_Settings_QueueRates("Treasure", _TickRate, _TimeoutRate)
THEN
LeaderLib_Queue_Create("LLLIB_ItemGenerationQueue", "LLLIB_ItemGenerationQueue", "LLLIB_Timers_Treasure_ItemQueue", _TickRate, "LLLIB_Events_Treasure_ProcessTreasure", "LLLIB_Events_OnTreasureGenerationComplete", "LLLIB_Events_OnGenerationQueueComplete");
LeaderLib_Queue_SetTimeout("LLLIB_ItemGenerationQueue", "LLLIB_Timers_Treasure_TreasureQueueTimeout", _TimeoutRate, "LLLIB_Events_OnTreasureGenerationTimeout");
LeaderLib_Queue_Start("LLLIB_ItemGenerationQueue");

PROC
LLLIB_Treasure_Internal_ProcessQueueItem((STRING)_ID)
AND
DB_LLLIB_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
THEN
NOT DB_LLLIB_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ProcessQueueItem] Generating treasure for [",_ID,"].");
DB_LLLIB_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID);
LLLIB_Treasure_Internal_CreateTreasureQueue(_ID, _Object, _TreasureID, _GenerationType);
LLLIB_Treasure_GenerateItems(_ID, _Object, _TreasureID, _GenerationType);
LLLIB_Treasure_Internal_StartTreasureQueue(_ID, _Object, _TreasureID, _GenerationType);

PROC
LLLIB_Treasure_Internal_RemoveFromJustRegistered((CHARACTERGUID)_Trader, (STRING)_TreasureID)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
AND
DB_LLLIB_Traders_Temp_TreasureJustRegistered(_TreasureID, _TraderID)
THEN
NOT DB_LLLIB_Traders_Temp_TreasureJustRegistered(_TreasureID, _TraderID);

PROC
LLLIB_Treasure_Internal_OnGenerationFailed((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnGenerationFailed] Failed to generate items for [",_ID,"]. Going to next item in queue.");
SetStoryEvent(_Object, "LeaderLib_Events_ResetGeneratingFlag");
//END_REGION

//REGION GENERATION_QUEUE_MANUAL_MODE
//Manual starting
PROC
LeaderLib_Treasure_AddToGenerationQueue((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Initialized(_Val)
AND
DB_LLLIB_Array_Length("LLLIB_ItemGenerationQueue", _Length)
AND
_Length > 0
AND
GlobalGetFlag("LeaderLib_DefaultEventFlowRunning", 0)
AND
NOT LeaderLib_Queue_QRY_IsRunning("LLLIB_ItemGenerationQueue")
THEN
TimerCancel("LLLIB_Timers_Treasure_ManualGenerationTimer");
TimerLaunch("LLLIB_Timers_Treasure_ManualGenerationTimer", 50);

IF
TimerFinished("LLLIB_Timers_Treasure_ManualGenerationTimer")
AND
NOT LeaderLib_Queue_QRY_IsRunning("LLLIB_ItemGenerationQueue")
THEN
LeaderLib_SendEvent("LeaderLib_Commands_StartTreasureGeneration");

IF
StoryEvent(_, "LLLIB_Events_OnGenerationQueueComplete")
AND
GlobalGetFlag("LeaderLib_DefaultEventFlowRunning", 0)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnTreasureQueueComplete] Treasure generation queue manually completed (outside of the event flow).");
//END_REGION

//REGION GENERATION_QUEUE_EVENTS
IF
StoryEvent(_, "LeaderLib_Commands_StartTreasureGeneration")
THEN
LeaderLib_Treasure_StartQueue();

IF
StoryEvent(_, "LLLIB_Events_Treasure_ProcessTreasure")
AND
DB_LLLIB_Queue_Temp_CurrentEntry(_ArrayID, _ID)
THEN
LLLIB_Treasure_Internal_ProcessQueueItem(_ID);

IF
StoryEvent(_, "LLLIB_Events_OnTreasureGenerationTimeout")
AND
DB_LLLIB_Queue_Temp_CurrentEntry(_ArrayID, _ID)
AND
DB_LLLIB_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:GenerationQueueTimeout] [",_ID,"] timed out.");
LLLIB_Treasure_Internal_OnGenerationFailed(_ID, _Object, _TreasureID, _GenerationType);

PROC
LLLIB_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:Internal:OnGenerationFinished] [",_ID,"] Object finished generating treasure [",_TreasureID,"].");
LeaderLib_Treasure_Internal_ApplyPostGenerationBonuses(_Object, _TreasureID);
LeaderLib_SendEvent("LLLIB_Events_OnTreasureGenerationComplete");

IF
StoryEvent(_, "LLLIB_Events_OnGenerationQueueComplete")
THEN
LeaderLib_Queue_Stop("LLLIB_ItemGenerationQueue");
LeaderLib_Queue_ClearQueue("LLLIB_ItemGenerationQueue");
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnGenerationFinished] Item generation queue complete. Stopped and cleared queue [LLLIB_ItemGenerationQueue].");
LeaderLib_SendEvent("LeaderLib_Events_OnTreasureGenerationComplete");
//END_REGION

//REGION STOP_QUEUE
IF
DB_LLLIB_EventFlow_StopEvent("LeaderLib_Commands_StartTreasureGeneration")
THEN
LLLIB_Treasure_Internal_StopQueue();
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StopQueue] Item generation queue forcefully stopped.");
NOT DB_LLLIB_EventFlow_StopEvent("LeaderLib_Commands_StartTreasureGeneration");

PROC
LLLIB_Treasure_Internal_StopQueue()
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StopQueue] Cleared generation queue.");
LeaderLib_Queue_Stop("LLLIB_ItemGenerationQueue");
LeaderLib_Queue_ClearQueue("LLLIB_ItemGenerationQueue");
//SysClear("DB_LLLIB_Treasure_Temp_ItemGenerationQueue", 4);
//END_REGION

//REGION FLAG_RESET
PROC
LLLIB_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT ObjectGetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure", 1)
THEN
SetStoryEvent(_Object, "LeaderLib_Events_ResetGeneratingFlag");

PROC
LLLIB_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
ObjectGetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure", 1)
AND
LeaderLib_QRY_ObjectTimerStarted(_Object, "LeaderLib_Timers_Treasure_ResetGeneratingFlag_", "LeaderLib_Events_ResetGeneratingFlag")
THEN
LeaderLib_ResetObjectTimer(_Object, "LeaderLib_Timers_Treasure_ResetGeneratingFlag_", 500);

PROC
LLLIB_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
ObjectGetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure", 1)
AND
NOT LeaderLib_QRY_ObjectTimerStarted(_Object, "LeaderLib_Timers_Treasure_ResetGeneratingFlag_", "LeaderLib_Events_ResetGeneratingFlag")
THEN
LeaderLib_StartObjectTimer(_Object, 500, "LeaderLib_Timers_Treasure_ResetGeneratingFlag_", "LeaderLib_Events_ResetGeneratingFlag");

IF
StoryEvent(_Object, "LeaderLib_Events_ResetGeneratingFlag")
THEN
ObjectClearFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure");
SetStoryEvent(_Object, "LeaderLib_Events_OnGenerationComplete");
//LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ResetGeneratedFlagTimer] Flag and database Temp_MatchedTreasure cleared.");

IF
StoryEvent(_Object, "LeaderLib_Events_ResetGeneratingFlag")
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
//END_REGION

//REGION COUNTING_COMPLETE
PROC
LLLIB_Treasure_Internal_CountingComplete((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 0)
AND
DB_LLLIB_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID)
AND
DB_LLLIB_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _CurrentAmount)
AND
LeaderLib_Treasure_QRY_ItemLimitNotMet(_Object, _TreasureID, _ItemEntry, _RequirementID, _GeneratedAmount, _CurrentAmount)
AND
DB_LLLIB_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate)
THEN
//LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:CountingComplete] Counting complete. Generating item by template.");
ObjectSetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure");
DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, 0, _AmountToCreate, 0);
NOT DB_LLLIB_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate);
NOT DB_LLLIB_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _CurrentAmount);
NOT DB_LLLIB_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID);

PROC
LLLIB_Treasure_Internal_CountingComplete((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 0)
AND
DB_LLLIB_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID)
AND
DB_LLLIB_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _CurrentAmount)
AND
NOT LeaderLib_Treasure_QRY_ItemLimitNotMet(_Object, _TreasureID, _ItemEntry, _RequirementID, _GeneratedAmount, _CurrentAmount)
THEN
NOT DB_LLLIB_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID);
NOT DB_LLLIB_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _CurrentAmount);
LLLIB_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _ItemEntry);

PROC
LLLIB_Treasure_Internal_CountingComplete((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 1)
AND
DB_LLLIB_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID)
AND
//DB_LLLIB_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemTemplate, _CurrentAmount)
DB_LLLIB_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _ItemTemplate, _ItemEntry, _CurrentAmount)
AND
LeaderLib_Treasure_QRY_ItemLimitNotMet(_Object, _TreasureID, _ItemEntry, _RequirementID, _GeneratedAmount, _CurrentAmount)
AND
DB_LLLIB_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate)
AND
IntegertoString(_AmountToCreate, _NextAmountStr)
AND
IntegertoString(_GeneratedAmount, _GenAmountStr)
AND
IntegertoString(_CurrentAmount, _CurrAmountStr)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:CountingComplete] Counting complete. Generating [",_NextAmountStr,"] (Current: [",_CurrAmountStr,"] Desired: [",_GenAmountStr,"]) item(s) by stat [",_ItemEntry,"].");
ObjectSetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure");
DB_LLLIB_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, 0, _AmountToCreate, 1);
NOT DB_LLLIB_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate);
NOT DB_LLLIB_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _ItemTemplate, _ItemEntry, _CurrentAmount);
NOT DB_LLLIB_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID);

PROC
LLLIB_Treasure_Internal_CountingComplete((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 1)
AND
DB_LLLIB_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID)
AND
DB_LLLIB_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _ItemTemplate, _ItemEntry, _CurrentAmount)
AND
NOT LeaderLib_Treasure_QRY_ItemLimitNotMet(_Object, _TreasureID, _ItemEntry, _RequirementID, _GeneratedAmount, _CurrentAmount)
THEN
NOT DB_LLLIB_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID);
NOT DB_LLLIB_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _ItemTemplate, _ItemEntry, _CurrentAmount);
LLLIB_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _ItemEntry);
//END_REGION

//REGION POST_GENERATION
PROC
LLLIB_Treasure_SendGeneratedEvent((GUIDSTRING)_Owner, (STRING)_OwnerID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_GeneratedEvent(_OwnerID, _ItemEntry, _OnGeneratedEvent)
THEN
SetStoryEvent(_Owner, _OnGeneratedEvent);

PROC
LLLIB_Treasure_RemoveIfOnlyOnce((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_OnlyOnce(_TreasureID, _ItemEntry, _OnCompletionEvent)
AND
DB_LLLIB_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
THEN
NOT DB_LLLIB_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID);

PROC
LLLIB_Treasure_RemoveIfOnlyOnce((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
DB_LLLIB_Treasure_OnlyOnce(_TreasureID, _TreasureTable, _OnCompletionEvent)
AND
DB_LLLIB_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)
THEN
NOT DB_LLLIB_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel);

PROC
LLLIB_Treasure_RemoveIfOnlyOnce((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_OnlyOnce(_TreasureID, _ItemEntry, _OnCompletionEvent)
THEN
//LeaderLib_Treasure_Clear_IfEmpty(_Object, _TreasureID, _ItemEntry);
ObjectSetFlag(_Object, "LLLIB_Treasure_GenerationEnded");
SetStoryEvent(_Object, _OnCompletionEvent);

PROC
LLLIB_Treasure_DisableGenerationForObject((GUIDSTRING)_Object)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 0)
THEN
ObjectSetFlag(_Object, "LLLIB_Treasure_GenerationEnded");

IF
ObjectWasTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly")
AND
ObjectGetFlag(_Object, "LLLIB_Treasure_GenerationEnded", 1)
THEN
ObjectClearFlag(_Object, "LLLIB_Treasure_GenerationEnded");

QRY
LeaderLib_Treasure_Internal_QRY_HasPostGenerationApplyBonuses((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LLLIB_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry)
THEN
DB_NOOP(1);

PROC
LeaderLib_Treasure_Internal_ApplyPostGenerationBonuses((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
LeaderLib_Treasure_Internal_QRY_HasPostGenerationApplyBonuses(_Object, _TreasureID)
AND
LeaderLib_QRY_ObjectTimerStarted(_Object, "LeaderLib_Timers_Treasure_ApplyBonusesTimer_")
THEN
LeaderLib_ResetObjectTimer(_Object, "LeaderLib_Timers_Treasure_ApplyBonusesTimer_", 25);

PROC
LeaderLib_Treasure_Internal_ApplyPostGenerationBonuses((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
LeaderLib_Treasure_Internal_QRY_HasPostGenerationApplyBonuses(_Object, _TreasureID)
AND
NOT LeaderLib_QRY_ObjectTimerStarted(_Object, "LeaderLib_Timers_Treasure_ApplyBonusesTimer_")
THEN
LeaderLib_StartObjectTimer(_Object, 25, "LeaderLib_Timers_Treasure_ApplyBonusesTimer_", "LeaderLib_Events_Internal_ApplyPostGenBonuses");

IF
StoryEvent(_Object, "LeaderLib_Events_Internal_ApplyPostGenBonuses")
AND
DB_LLLIB_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry)
THEN
NOT DB_LLLIB_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:Internal:ApplyPostGenerationBonuses] Applying postgen bonuses for ItemEntry [",_ItemEntry,"] with _TreasureID [",_TreasureID,"]. ");
LLLIB_Treasure_AdjustItemLevel(_Item, _TreasureID, _ItemEntry);
LLLIB_Treasure_ApplyDeltaMods(_Item, _TreasureID, _ItemEntry);
LLLIB_Treasure_InsertRunes(_Item, _TreasureID, _ItemEntry);
//END_REGION

//REGION ITEM_POSTGEN_MODIFIERS
PROC
LeaderLib_Treasure_Internal_CheckPostGenBonuses((GUIDSTRING)_Object, (ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
LeaderLib_Treasure_QRY_HasPostGenerationBonuses(_TreasureID, _ItemEntry)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:CheckPostGenBonuses] Item [",_ItemEntry,"] generated from treasure [",_TreasureID,"] has post-gen bonuses.");
DB_LLLIB_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry);

QRY
LeaderLib_Treasure_QRY_HasPostGenerationBonuses((STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_ItemLevel(_TreasureID, _ItemEntry, _UsePartyLevel, _MinLevel, _MaxLevel)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_HasPostGenerationBonuses((STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_ItemDeltaMods(_ID, _TreasureID, _ItemEntry, _Deltamod, _Chance)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_HasPostGenerationBonuses((STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_ItemRunes(_ID, _TreasureID, _ItemEntry, _Rune, _Chance)
THEN
DB_NOOP(1);

PROC
LLLIB_Treasure_AdjustItemLevel((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_ItemLevel(_TreasureID, _ItemEntry, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
_UsePartyLevel > 0
AND
LeaderLib_Helper_QRY_GetHighestPlayerLevel()
AND
DB_LeaderLib_Helper_Temp_HighestPlayerLevel(_Level)
THEN
ItemLevelUpTo(_Item, _Level);
NOT DB_LeaderLib_Helper_Temp_HighestPlayerLevel(_Level);

PROC
LLLIB_Treasure_AdjustItemLevel((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_ItemLevel(_TreasureID, _ItemEntry, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
_UsePartyLevel <= 0
AND
LeaderLib_Random_QRY(_MinLevel, _MaxLevel)
AND
DB_LeaderLib_Temp_RandomResult(_Level)
THEN
ItemLevelUpTo(_Item, _Level);
NOT DB_LeaderLib_Temp_RandomResult(_Level);

QRY
LeaderLib_Treasure_QRY_Internal_RollSucceeded((INTEGER)_Chance)
AND
_Chance <= -1
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_Internal_RollSucceeded((INTEGER)_Chance)
AND
_Chance >= 100
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_Internal_RollSucceeded((INTEGER)_Chance)
AND
_Chance > 0
AND
_Chance < 100
AND
LeaderLib_Random_QRY(100)
AND
DB_LeaderLib_Temp_RandomResult(_Roll)
AND
LeaderLog_QRY_LogInt("TRACE", "[LeaderLib:TreasureSystem:Internal:RollSucceeded] Rolled: [",_Roll,"/",_Chance,"].")
AND
_Roll <= _Chance
THEN
NOT DB_LeaderLib_Temp_RandomResult(_Roll); // Also cleared by LeaderLib_Random_QRY

QRY
LeaderLib_Treasure_QRY_Internal_CanApplyDeltamod((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_Deltamod)
AND
NOT ItemHasDeltaModifier(_Item, _Deltamod, _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_Internal_CanApplyDeltamod((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_Deltamod)
AND
ItemHasDeltaModifier(_Item, _Deltamod, _Count)
AND
DB_LLLIB_Treasure_DeltaModLimit(_TreasureID, _ItemEntry, _Deltamod, _Max)
AND
_Count < _Max
THEN
DB_NOOP(1);

PROC
LLLIB_Treasure_ApplyDeltaMods((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_ItemDeltaMods(_ID, _TreasureID, _ItemEntry, _Deltamod, _Chance)
AND
LeaderLib_Treasure_QRY_Internal_CanApplyDeltamod(_Item, _TreasureID, _ItemEntry, _Deltamod)
AND
LeaderLib_Treasure_QRY_Internal_RollSucceeded(_Chance)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:ApplyDeltaMods] Added deltamod [",_Deltamod,"] to [",_TreasureID,"][",_ItemEntry,"].");
ItemAddDeltaModifier(_Item, _Deltamod);

PROC
LLLIB_Treasure_InsertRunes((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LLLIB_Treasure_ItemRunes(_ID, _TreasureID, _ItemEntry, _Rune, _Chance)
THEN
LLLIB_Treasure_Internal_TryInsertRune(_Item, _Rune, _Chance);

PROC
LLLIB_Treasure_Internal_TryInsertRune((ITEMGUID)_Item, (STRING)_Rune, (INTEGER)_Chance)
AND
LeaderLib_Treasure_QRY_Internal_RollSucceeded(_Chance)
AND
NOT LeaderLib_Treasure_QRY_InsertRuneInSlot(_Item, _Rune, 0)
AND
NOT LeaderLib_Treasure_QRY_InsertRuneInSlot(_Item, _Rune, 1)
AND
NOT LeaderLib_Treasure_QRY_InsertRuneInSlot(_Item, _Rune, 2)
AND
IntegertoString(_Chance, _ChanceStr)
THEN
LeaderLog_Log("TRACE", "[LeaderLib:TreasureSystem:Internal:TryInsertRune] Failed to insert rune [",_Rune,"] into item. Chance [",_ChanceStr,"%].");

PROC
LLLIB_Treasure_Internal_TryInsertRune((ITEMGUID)_Item, (STRING)_Rune, (INTEGER)_Chance)
AND
DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
THEN
NOT DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item);

QRY
LeaderLib_Treasure_QRY_InsertRuneInSlot((ITEMGUID)_Item, (STRING)_Rune, (INTEGER)_Slot)
AND
NOT ItemGetRuneItemTemplate(_Item, _Slot, _)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot) //Prevents crashes from adding runes into non-existent slots
THEN
ItemInsertRune(NULL_00000000-0000-0000-0000-000000000000, _Item, _Rune, _Slot);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot)
AND
NOT DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
GetTemplate(_Item, _Template)
AND
StringContains(_Template, "Amulet", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_Armor_Amulet_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_Armor_Amulet_EmptyRuneSlot", _)
THEN
DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot)
AND
NOT DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
GetTemplate(_Item, _Template)
AND
StringContains(_Template, "WPN", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_Weapon_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_Weapon_EmptyRuneSlot", _)
THEN
DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot)
AND
NOT DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
GetTemplate(_Item, _Template)
AND
StringContains(_Template, "EQ_", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor(_Item, _Slot, _Template)
THEN
DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_Template)
AND
NOT DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
StringContains(_Template, "Upperbody", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_Armor_UpperBody_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_Armor_UpperBody_EmptyRuneSlot", _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_Template)
AND
NOT DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
StringContains(_Template, "Lowerbody", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_LLLIB_Armor_LowerBody_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_LLLIB_Armor_LowerBody_EmptyRuneSlot", _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_Template)
AND
NOT DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
StringContains(_Template, "Legs", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_LLLIB_Armor_Boots_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_LLLIB_Armor_Boots_EmptyRuneSlot", _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_Template)
AND
NOT DB_LLLIB_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
StringContains(_Template, "Arms", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_LLLIB_Armor_Arms_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_LLLIB_Armor_Arms_EmptyRuneSlot", _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_RuneSlotDeltaMod)
AND
ItemHasDeltaModifier(_Item, _RuneSlotDeltaMod, _Count)
AND
IntegerSubtract(_Count, 1, _Slots)
AND
_Slots < _Slot
THEN
ItemAddDeltaModifier(_Item, _RuneSlotDeltaMod);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_RuneSlotDeltaMod)
AND
NOT ItemHasDeltaModifier(_Item, _RuneSlotDeltaMod, _)
THEN
ItemAddDeltaModifier(_Item, _RuneSlotDeltaMod);
//END_REGION

//REGION GENERATION_EVENTS
//Containers
IF
//ItemOpened(_Object)
CharacterUsedItem(_, _Object)
AND
IsTagged(_Object, "LLLIB_Item_IgnoreOpened", 0)
AND
LeaderLib_Treasure_QRY_ObjectCanStartGeneration((GUIDSTRING)_Object)
AND
ItemIsContainer((ITEMGUID)_Object, 1)
AND
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
//AND
//Don't check the IteMGenerationType database since this is the default way for containers
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "OPENED");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

IF
ObjectFlagSet("LeaderLib_Treasure_GenerateNow", _Object, _)
AND
LeaderLib_Helper_QRY_ClearObjectFlag(_Object, "LeaderLib_Treasure_GenerateNow")
AND
ObjectGetFlag(_Object, "LLLIB_Treasure_IsGeneratingTreasure", 0)
AND
LeaderLib_Treasure_QRY_GetTreasureID(_Object)
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:GenerateNow] Manually generating items for treasure with ID [",_TreasureID,"]");
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "MANUAL");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Trader_QRY_DefaultTradeGenerationIgnored((CHARACTERGUID)_Trader)
AND
IsTagged(_Trader, "LeaderLib_Trader_IgnoreTradeGeneration", 1)
THEN
DB_NOOP(1);

//Disable trade generation events if some other type is registered
QRY
LeaderLib_Trader_QRY_DefaultTradeGenerationIgnored((CHARACTERGUID)_Trader)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
AND
DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
AND
DB_LLLIB_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
AND
_GenerationType != "TRADE_GENERATION_END"
THEN
DB_NOOP(1);

IF
TradeGenerationStarted(_Trader)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
AND
LeaderLib_Treasure_QRY_ObjectCanStartGeneration(_Trader)
AND
DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
AND
LeaderLib_Treasure_QRY_TreasureHasGenerationType(_TreasureID, "TRADE_GENERATION_START")
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Trader, _TreasureID, "TRADE_GENERATION_START");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Trader, _TreasureID);

IF
TradeGenerationEnded(_Trader)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
AND
LeaderLib_Treasure_QRY_ObjectCanStartGeneration(_Trader)
AND
NOT LeaderLib_Trader_QRY_DefaultTradeGenerationIgnored(_Trader)
AND
DB_LLLIB_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
//AND
//Skip this check since it's the default generation type for traders
//LeaderLib_Treasure_QRY_TreasureHasGenerationType(_TreasureID, "TRADE_GENERATION_END")
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Trader, _TreasureID, "TRADE_GENERATION_END");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Trader, _TreasureID);

IF
DialogStarted(_Dialog, _Instance)
AND
DB_LLLIB_Treasure_RegisteredGenerationTypes("DIALOG_STARTED")
AND
DialogGetInvolvedNPC(_Instance, 1, _Object)
AND
LeaderLib_Treasure_QRY_ObjectCanStartGeneration(_Object)
AND
LeaderLib_Treasure_QRY_GetTreasureID(_Object)
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
AND
LeaderLib_Treasure_QRY_TreasureHasGenerationType(_TreasureID, "DIALOG_STARTED")
THEN
//LeaderLog_Log("TRACE","[LeaderLib:TreasureSystem:DialogStarted] Starting generation queue for object with TreasureID [",_TreasureID,"].");
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "DIALOG_STARTED");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

IF
DialogEnded(_Dialog, _Instance)
AND
DB_LLLIB_Treasure_RegisteredGenerationTypes("DIALOG_ENDED")
AND
DialogGetInvolvedNPC(_Instance, 1, _Object)
AND
LeaderLib_Treasure_QRY_ObjectCanStartGeneration(_Object)
AND
LeaderLib_Treasure_QRY_GetTreasureID(_Object)
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
AND
LeaderLib_Treasure_QRY_TreasureHasGenerationType(_TreasureID, "DIALOG_ENDED")
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "DIALOG_ENDED");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

IF
ObjectFlagSet(_Flag, _, _)
THEN
LLLIB_Treasure_Internal_GenerateByFlag(_Flag, "Object");

IF
GlobalFlagSet(_Flag)
THEN
LLLIB_Treasure_Internal_GenerateByFlag(_Flag, "Global");

/*
IF
StoryEvent(_,"LeaderLib_Initialized")
AND
DB_CurrentLevel(_Level)
AND
IsCharacterCreationLevel(_Level, 0)
THEN
//Give some time for other mods to register treasure
TimerLaunch("LLLIB_Timers_Treasure_LevelLoadedTreasureTimer", 200);

IF
TimerFinished("LLLIB_Timers_Treasure_LevelLoadedTreasureTimer")
*/

IF
RegionStarted(_Level)
AND
IsCharacterCreationLevel(_Level, 0)
THEN
DB_LLLIB_Treasure_Temp_LevelLoaded(_Level);

IF
GameStarted(_Level,_)
AND
DB_LLLIB_Treasure_Temp_LevelLoaded(_Level)
AND
DB_LLLIB_Treasure_RegisteredGenerationTypes("LEVEL_LOADED")
AND
LeaderLib_Treasure_QRY_GetTreasureByGenerationType("LEVEL_LOADED")
AND
DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure("LEVEL_LOADED", _TreasureID)
AND
LeaderLib_Treasure_QRY_GetTreasureObject(_TreasureID, "LEVEL_LOADED")
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:Level_Loaded] Added treasure [",_TreasureID,"] to generation queue for [LEVEL_LOADED] generation type.");
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "LEVEL_LOADED");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
NOT DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure("LEVEL_LOADED", _TreasureID);

IF
GameStarted(_Level,_)
AND
DB_LLLIB_Treasure_Temp_LevelLoaded(_Level)
THEN
NOT DB_LLLIB_Treasure_Temp_LevelLoaded(_Level);

IF
CharacterLeveledUp(_Player)
AND
CharacterIsPlayer(_Player, 1)
THEN
TimerCancel("LLLIB_Timers_Treasure_LevelUpTreasureTimer");
TimerLaunch("LLLIB_Timers_Treasure_LevelUpTreasureTimer", 250);

IF
TimerFinished("LLLIB_Timers_Treasure_LevelUpTreasureTimer")
AND
DB_LLLIB_Treasure_RegisteredGenerationTypes("PARTY_LEVELED_UP")
AND
LeaderLib_Treasure_QRY_GetTreasureByGenerationType("PARTY_LEVELED_UP")
AND
DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure("PARTY_LEVELED_UP", _TreasureID)
AND
LeaderLib_Treasure_QRY_GetTreasureObject(_TreasureID, "PARTY_LEVELED_UP")
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
AND
NOT DB_LLLIB_Treasure_Temp_PartyLeveledUpGenerationTimer(_, _TreasureID)
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "PARTY_LEVELED_UP");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
NOT DB_LLLIB_Treasure_Temp_GenerationTypeToTreasure("PARTY_LEVELED_UP", _TreasureID);

//When an object is found by its registered treasure ID and template
IF
StoryEvent(_, "LLLIB_Events_Treasure_ContinueGeneration")
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
AND
DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType)
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, _GenerationType);
NOT DB_LLLIB_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType);
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

//To prevent multiple generation events when more than one player levels up at the same time
PROC
LeaderLib_Treasure_AddToGenerationQueue((GUIDSTRING)_Object, (STRING)_TreasureID, "PARTY_LEVELED_UP")
AND
NOT DB_LLLIB_Treasure_Temp_PartyLeveledUpGenerationTimer(_, _TreasureID)
AND
StringConcatenate("LLLIB_Timers_Treasure_PartyLeveledUpGenerationBlocker_", _TreasureID, _TimerName)
THEN
DB_LLLIB_Treasure_Temp_PartyLeveledUpGenerationTimer(_TimerName, _TreasureID);
TimerLaunch(_TimerName, 2000);

IF
TimerFinished(_TimerName)
AND
DB_LLLIB_Treasure_Temp_PartyLeveledUpGenerationTimer(_TimerName, _TreasureID)
THEN
NOT DB_LLLIB_Treasure_Temp_PartyLeveledUpGenerationTimer(_TimerName, _TreasureID);

//Use a proc here to avoid a weird crash
IF
DB_LLLIB_Requirements_JustUnlocked(_RequirementID)
THEN
LLLIB_Treasure_Internal_GenerateFromRequirement(_RequirementID);

PROC
LLLIB_Treasure_Internal_GenerateFromRequirement((STRING)_RequirementID)
AND
DB_LLLIB_Treasure_RegisteredGenerationTypes("REQUIREMENT_UNLOCKED")
AND
LeaderLib_Treasure_QRY_GetTreasureByRequirement(_RequirementID)
AND
DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
AND
LeaderLib_Treasure_QRY_TreasureHasGenerationType(_TreasureID, "REQUIREMENT_UNLOCKED")
AND
LeaderLib_Treasure_QRY_GetTreasureObject(_TreasureID, "REQUIREMENT_UNLOCKED")
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem] Generating [",_TreasureID,"] due to requirement [",_RequirementID,"] unlocking.");
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "REQUIREMENT_UNLOCKED");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

PROC
LLLIB_Treasure_Internal_GenerateFromRequirement((STRING)_RequirementID)
AND
DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
NOT DB_LLLIB_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);
//END_REGION

//REGION TREASURE_FLAG_GEN
QRY
LeaderLib_Treasure_QRY_IsGenerationFlag((STRING)_Flag, (STRING)_FlagType)
AND
DB_LLLIB_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID)
THEN
NOT DB_LLLIB_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID);

QRY
LeaderLib_Treasure_QRY_IsGenerationFlag((STRING)_Flag, (STRING)_FlagType)
AND
DB_LLLIB_Treasure_ItemGenerationFlag(_TreasureID, _ItemEntry, _Flag, _FlagType)
AND
NOT DB_LLLIB_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID)
THEN
DB_LLLIB_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID);

PROC
LLLIB_Treasure_Internal_GenerateByFlag((STRING)_Flag, (STRING)_FlagType)
AND
DB_LLLIB_Treasure_RegisteredGenerationTypes("FLAG")
AND
LeaderLib_Treasure_QRY_IsGenerationFlag(_Flag, _FlagType)
AND
DB_LLLIB_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID)
AND
LeaderLib_Treasure_QRY_GetTreasureObject(_TreasureID, "FLAG")
AND
DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "FLAG");
NOT DB_LLLIB_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
//END_REGION

//REGION CONTAINERS
IF
ObjectFlagSet("LLLIB_Treasure_GenerationSuccessful", _Object, _)
AND
ItemIsContainer((ITEMGUID)_Object, 1)
THEN
LLLIB_Treasure_DisableGenerationForObject((GUIDSTRING)_Object);
ObjectClearFlag(_Object, "LLLIB_Treasure_GenerationSuccessful");
//END_REGION

//REGION DONE_GENERATING
IF
ItemTemplateRemovedFromCharacter(_ItemEntry, _Item, _Object)
AND
DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 1)
THEN
NOT DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry);

IF
ItemTemplateRemovedFromContainer(_ItemEntry, _Item, _Object)
AND
DB_LLLIB_Treasure_ItemDoneGenerating((GUIDSTRING)_Object, _TreasureID, _ItemEntry)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 1)
THEN
NOT DB_LLLIB_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry);
//END_REGION

//REGION DEBUG
/*
QRY
LeaderLib_Treasure_QRY_Debug_CompareAmounts((STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_GeneratedAmount, (INTEGER)_CurrentAmount)
AND
IntegertoString(_GeneratedAmount, _GenStr)
AND
IntegertoString(_CurrentAmount, _CurStr)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:Debug] Comparing item amounts for [",_TreasureID,":",_ItemEntry,"] - ",_CurStr,"/",_GenStr);
*/

PROC
LLLIB_Treasure_CountItems((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_GeneratedAmount, (STRING)_RequirementID, (INTEGER)_IsStat)
AND
_IsStat <= 0
AND
ItemTemplateIsInCharacterInventory((CHARACTERGUID)_Object, _ItemEntry, _Val)
AND
IntegertoString(_Val, _ValStr)
AND
GetTemplate(_Object, _Template)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:CountItems] Item template [",_TreasureID,"]:[",_ItemEntry,"][",_Template,"] found = ", _ValStr);

/*
IF
StoryEvent(_Object, _Event)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:Debug] Debugging event [",_Event,"]. It is the completion event?");
*/
//END_REGION
EXITSECTION

ENDEXITSECTION
ParentTargetEdge "LaughingLeader__LeaderLib"
